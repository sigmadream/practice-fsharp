<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Sangkon Han">
<meta name="dcterms.date" content="2024-12-31">

<title>F# - 함수, 함수, 그리고 함수 – F#</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../notes/fsharp04.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-ddd961a2510921635943dfbbd19534c4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
<meta property="og:title" content="F# - 함수, 함수, 그리고 함수 – F#">
<meta property="og:description" content="Learn F# with MVP!">
<meta property="og:site_name" content="F#">
<meta name="twitter:title" content="F# - 함수, 함수, 그리고 함수 – F#">
<meta name="twitter:description" content="Learn F# with MVP!">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">F#</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/sigmadream/practice-fsharp"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../notes/fsharp05.html">F# - 함수, 함수, 그리고 함수</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/fsharp01.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">F# - 시작하기</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/fsharp02.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">F# - 강력한 실행 환경</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/fsharp03.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">F# - 변수</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/fsharp04.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">F# - 타입</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/fsharp05.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">F# - 함수, 함수, 그리고 함수</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#summary" id="toc-summary" class="nav-link active" data-scroll-target="#summary">Summary</a></li>
  <li><a href="#functions-higher-order-functions-and-recursion" id="toc-functions-higher-order-functions-and-recursion" class="nav-link" data-scroll-target="#functions-higher-order-functions-and-recursion">Functions, Higher-Order Functions, and Recursion</a>
  <ul class="collapse">
  <li><a href="#defining-functions" id="toc-defining-functions" class="nav-link" data-scroll-target="#defining-functions">Defining Functions</a></li>
  <li><a href="#function-parameters-and-curried-functions" id="toc-function-parameters-and-curried-functions" class="nav-link" data-scroll-target="#function-parameters-and-curried-functions">Function Parameters and Curried Functions</a></li>
  <li><a href="#named-and-anonymous-functions" id="toc-named-and-anonymous-functions" class="nav-link" data-scroll-target="#named-and-anonymous-functions">Named and Anonymous Functions</a></li>
  <li><a href="#function-arguments-and-default-values" id="toc-function-arguments-and-default-values" class="nav-link" data-scroll-target="#function-arguments-and-default-values">Function Arguments and Default Values</a></li>
  <li><a href="#recursive-functions" id="toc-recursive-functions" class="nav-link" data-scroll-target="#recursive-functions">Recursive Functions</a></li>
  <li><a href="#first-class-and-higher-order-functions" id="toc-first-class-and-higher-order-functions" class="nav-link" data-scroll-target="#first-class-and-higher-order-functions">First-Class and Higher-Order Functions</a></li>
  <li><a href="#first-class-functions" id="toc-first-class-functions" class="nav-link" data-scroll-target="#first-class-functions">First-Class Functions</a></li>
  <li><a href="#higher-order-functions" id="toc-higher-order-functions" class="nav-link" data-scroll-target="#higher-order-functions">Higher-Order Functions</a></li>
  <li><a href="#function-composition-and-partial-application" id="toc-function-composition-and-partial-application" class="nav-link" data-scroll-target="#function-composition-and-partial-application">Function Composition and Partial Application</a></li>
  <li><a href="#anonymous-functions" id="toc-anonymous-functions" class="nav-link" data-scroll-target="#anonymous-functions">Anonymous Functions</a></li>
  <li><a href="#function-currying" id="toc-function-currying" class="nav-link" data-scroll-target="#function-currying">Function Currying</a></li>
  <li><a href="#recursive-functions-and-tail-recursion" id="toc-recursive-functions-and-tail-recursion" class="nav-link" data-scroll-target="#recursive-functions-and-tail-recursion">Recursive Functions and Tail Recursion</a></li>
  <li><a href="#defining-recursive-functions" id="toc-defining-recursive-functions" class="nav-link" data-scroll-target="#defining-recursive-functions">Defining Recursive Functions</a></li>
  <li><a href="#tail-recursion" id="toc-tail-recursion" class="nav-link" data-scroll-target="#tail-recursion">Tail Recursion</a></li>
  <li><a href="#benefits-of-tail-recursion" id="toc-benefits-of-tail-recursion" class="nav-link" data-scroll-target="#benefits-of-tail-recursion">Benefits of Tail Recursion</a></li>
  <li><a href="#function-composition-and-partial-application-1" id="toc-function-composition-and-partial-application-1" class="nav-link" data-scroll-target="#function-composition-and-partial-application-1">Function Composition and Partial Application</a></li>
  <li><a href="#backward-composition" id="toc-backward-composition" class="nav-link" data-scroll-target="#backward-composition">Backward Composition</a></li>
  <li><a href="#partial-application" id="toc-partial-application" class="nav-link" data-scroll-target="#partial-application">Partial Application</a></li>
  <li><a href="#combining-composition-and-partial-application" id="toc-combining-composition-and-partial-application" class="nav-link" data-scroll-target="#combining-composition-and-partial-application">Combining Composition and Partial Application</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/sigmadream/practice-fsharp/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">F# - 함수, 함수, 그리고 함수</h1>
  <div class="quarto-categories">
    <div class="quarto-category">F#,</div>
    <div class="quarto-category">.NET</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Sangkon Han </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 31, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<p>F#에서 함수는 let 키워드로 정의하며, 간단한 구문과 유형 추론을 통해 매개변수와 반환값을 명시하거나 추론할 수 있다. 함수가 1급 시민으로 취급되므로 다른 값처럼 변수에 할당하거나 인수로 전달할 수 있어, 고차 함수와 함수 합성, 부분 적용 등 강력한 기능을 제공한다. 또한 재귀 함수와 꼬리 재귀 최적화를 통해 반복을 명확하고 효율적으로 처리할 수 있으며, 커링을 활용하여 여러 인자를 단계적으로 적용하는 유연한 코드를 작성할 수 있다.</p>
</section>
<section id="functions-higher-order-functions-and-recursion" class="level2">
<h2 class="anchored" data-anchor-id="functions-higher-order-functions-and-recursion">Functions, Higher-Order Functions, and Recursion</h2>
<p>F#에서 함수를 정의하고 사용하는 데 필요한 필수 개념을 소개합니다. 해당 부분은 F#의 시작이자, 전부라 할 수 있습니다. 해당 부분을 통해서 표현력 높고, 재사용이 가능한 코드를 작성하기 위한 함수형 언어의 특징을 확인하실 수 있습니다.</p>
<ul>
<li>Defining Functions and Basic Syntax</li>
</ul>
<p>함수는 함수형 프로그래밍 패러다임의 중심이 되는 핵심 구조입니다. 함수는 특정 작업을 수행하도록 정의되며 재사용 가능한 코드 블록을 만드는 데 기본이 됩니다. 기본 구조는 함수의 이름을 지정하고 매개변수와 반환값을 지정하는 것입니다. 함수를 사용하면 복잡한 로직을 관리 가능하고 재사용 가능한 구성 요소로 추상화할 수 있으므로 함수를 정의하고 사용하는 방법을 이해하는 것이 중요합니다.</p>
<ul>
<li>First-Class and Higher-Order Functions</li>
</ul>
<p>F#에서 함수는 1급 함수입니다. 즉, 다른 값처럼 취급할 수 있습니다. 이를 통해 다른 함수를 인수로 받거나 함수를 결과로 반환하는 함수인 고차 함수를 사용할 수 있습니다. 고차 함수는 여러 함수를 결합하여 새로운 함수를 생성하는 함수 구성과 같은 강력한 프로그래밍 기법을 가능하게 합니다. 이는 코드 재사용과 함수 구성을 촉진하여 코드를 보다 모듈화하고 유지 관리하기 쉽게 만듭니다. 유연하고 강력한 F# 프로그램을 작성하려면 고차 함수를 이해하는 것이 필수적입니다.</p>
<ul>
<li>Recursive Functions and Tail Recursion</li>
</ul>
<p>재귀는 함수형 프로그래밍의 기본 개념으로, 함수가 스스로를 호출하여 문제의 작은 부분을 해결하는 방식입니다. F#에서 재귀 함수는 기존의 반복 구성을 대체하여 특정 알고리즘을 보다 자연스럽게 표현할 수 있습니다. 재귀는 함수형 구조와 결합할 때 특히 강력할 수 있습니다. 재귀 호출이 함수의 최종 연산이 되는 꼬리 재귀는 중요한 최적화 기법입니다. 호출 스택을 늘리지 않고 재귀 함수를 실행할 수 있으므로 성능이 향상되고 스택 오버플로 문제를 방지할 수 있습니다.</p>
<ul>
<li>Function Composition and Partial Application</li>
</ul>
<p>함수 합성과 부분 적용은 함수형 프로그래밍 고급 기법입니다. 두 기법 모두 기존의 연산을 활용하는 것이 주된 목적이빈다. 이러한 기술을 통해 개발자는 보다 표현력이 풍부하고 재사용 가능한 함수를 구축하여 문제 해결에 대한 기능적 접근을 용이하게 할 수 있습니다.</p>
<section id="defining-functions" class="level3">
<h3 class="anchored" data-anchor-id="defining-functions">Defining Functions</h3>
<p>F#에서 함수는 let 키워드 다음에 함수 이름, 매개 변수, 함수 본문을 사용하여 정의합니다. 이 구문은 간단하고 명확성을 강조하므로 코드를 유지 관리하고 이해하는 데 매우 중요합니다. 예를 들어 두 숫자를 더하는 간단한 함수를 정의하려면 다음과 같이 작성합니다. F#의 유형 추론 시스템은 사용법에 따라 매개변수의 유형과 반환값을 자동으로 결정합니다. 예를 들어 add 함수는 사용 방식에 따라 정수 또는 부동 소수점 숫자로 작동하는 것으로 추론됩니다. 그러나 가독성을 높이고 오류를 방지하기 위해 유형을 명시적으로 지정할 수도 있습니다:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode fsharp code-with-copy"><code class="sourceCode fsharp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add x y = x + y</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add <span class="op">(</span>x: <span class="dt">int</span><span class="op">)</span> <span class="op">(</span>y: <span class="dt">int</span><span class="op">)</span> : <span class="dt">int</span> = x + y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>F#의 함수는 더 복잡한 경우 여러 줄로 정의할 수도 있습니다. 들여쓰기를 사용하여 함수 본문과 함수 정의를 구분할 수 있습니다. 이 함수에서 계산이자는 원금, 이자율, 연수를 기준으로 이자를 계산합니다. 함수 내부에서 let 키워드를 사용하여 지역 변수 이자를 정의하면 계산이 간단해집니다. 함수 본문은 여러 줄에 걸쳐 있으며 결과는 최종 이자 값입니다.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode fsharp code-with-copy"><code class="sourceCode fsharp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> calculateDiscriminant a b c =</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> discriminant = <span class="op">(</span>b * b<span class="op">)</span> - <span class="dv">4</span> * a * c</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    discriminant</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="function-parameters-and-curried-functions" class="level3">
<h3 class="anchored" data-anchor-id="function-parameters-and-curried-functions">Function Parameters and Curried Functions</h3>
<p>F# 함수는 여러 매개변수가 있는 함수를 부분적으로 적용할 수 있는 커링을 지원합니다. 즉, 하나의 매개변수를 취하고 나머지 매개변수를 취하는 다른 함수를 반환하는 함수를 정의할 수 있습니다. double은 곱하기 함수에 2를 첫 번째 인수로 적용하여 만든 새로운 함수입니다. double을 단일 인수로 호출하면 해당 인수에 2를 곱합니다.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode fsharp code-with-copy"><code class="sourceCode fsharp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> multiply x y = x * y</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">double</span> = multiply <span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="named-and-anonymous-functions" class="level3">
<h3 class="anchored" data-anchor-id="named-and-anonymous-functions">Named and Anonymous Functions</h3>
<p>F#에서는 명명된 함수와 익명 함수를 모두 사용할 수 있습니다. 명명된 함수는 앞서 설명한 대로 let 키워드를 사용하여 정의합니다. 람다 함수라고도 하는 익명 함수는 짧은 일회성 연산에 유용합니다. <code>fun x -&gt; x * x</code>는 입력을 제곱하는 익명 함수입니다. List.map과 함께 숫자 목록의 각 요소에 제곱 연산을 적용하는 데 사용됩니다.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode fsharp code-with-copy"><code class="sourceCode fsharp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> numbers = <span class="op">[</span><span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span><span class="op">]</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> squaredNumbers = List<span class="kw">.</span>map <span class="op">(</span><span class="kw">fun</span> x -&gt; x * x<span class="op">)</span> numbers</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="function-arguments-and-default-values" class="level3">
<h3 class="anchored" data-anchor-id="function-arguments-and-default-values">Function Arguments and Default Values</h3>
<p>F# 함수에는 매개변수에 대한 기본값을 지정할 수도 있습니다. 이를 통해 정의된 매개변수 수보다 적은 수의 인수로 호출할 수 있는 유연한 함수를 만들 수 있습니다. 이 경우 greet에는 이름과 인사말이 모두 필요하지만 greetWithDefault는 기본 인사말(“Hello”)을 사용합니다. 이 패턴은 적절한 기본값을 가진 선택적 매개변수가 있는 함수에 유용합니다.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode fsharp code-with-copy"><code class="sourceCode fsharp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> greet name <span class="op">(</span>salutation: <span class="dt">string</span><span class="op">)</span> =</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    printfn <span class="st">"%s, %s!"</span> salutation name</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> greetWithDefault name =</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    greet name <span class="st">"Hello"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="recursive-functions" class="level3">
<h3 class="anchored" data-anchor-id="recursive-functions">Recursive Functions</h3>
<p>F#은 함수가 문제를 해결하기 위해 스스로를 호출하는 재귀를 지원합니다. 예를 들어 계승 함수는 종종 재귀적으로 정의됩니다:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode fsharp code-with-copy"><code class="sourceCode fsharp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> factorial n =</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n &lt;= <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> n * factorial <span class="op">(</span>n - <span class="dv">1</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>factorial은 숫자 n의 계승을 계산하는 재귀 함수이며, rec 키워드는 해당 함수가 재귀 함수임을 나타냅니다. F#의 재귀 함수는 강력하지만 성능 문제를 피하기 위해 주의해서 사용해야 하므로 고급 시나리오에서는 꼬리 재귀 최적화를 고려해야 합니다. F#에서 함수를 정의하는 것은 직관적이고 강력하며 유형 추론, 여러 줄 함수 정의, 커링 및 재귀를 활용하여 광범위한 프로그래밍 작업을 효율적으로 처리할 수 있습니다.</p>
</section>
<section id="first-class-and-higher-order-functions" class="level3">
<h3 class="anchored" data-anchor-id="first-class-and-higher-order-functions">First-Class and Higher-Order Functions</h3>
<p>F#에서 함수는 단순한 연산이나 프로시저가 아니라 1급 시민입니다. 이 기본 개념 덕분에 함수는 다른 데이터 유형과 마찬가지로 취급할 수 있습니다. 변수에 할당하고, 인수로 전달하고, 다른 함수에서 반환할 수 있습니다. 이 섹션에서는 일차 함수와 고차 함수의 특성 및 F#에서의 실제 적용에 대해 살펴봅니다.</p>
</section>
<section id="first-class-functions" class="level3">
<h3 class="anchored" data-anchor-id="first-class-functions">First-Class Functions</h3>
<p>F#에서 함수는 정수나 문자열과 같은 다른 데이터 유형처럼 쉽게 조작할 수 있는 1등 시민입니다. 이러한 특성은 함수형 프로그래밍에서 핵심적인 요소로, 높은 수준의 유연성과 추상화를 가능하게 합니다. 예를 들어 변수에 함수를 할당할 수 있습니다:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode fsharp code-with-copy"><code class="sourceCode fsharp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add x y = x + y</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> addFunction = add</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> result = addFunction <span class="dv">5</span> <span class="dv">3</span> //<span class="co"> result is 8</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>여기서 addFunction에는 add 함수가 할당되어 있습니다. 이는 함수가 다른 값과 마찬가지로 전달될 수 있음을 보여줍니다. 함수는 다른 함수에서 반환될 수도 있어 다용도로 사용할 수 있음을 보여줍니다. 다른 함수를 반환하는 함수를 생각해 봅시다:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode fsharp code-with-copy"><code class="sourceCode fsharp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> multiplier factor =</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> multiply x = x * factor</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        multiply</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">double</span> = multiplier <span class="dv">2</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> result = <span class="dt">double</span> <span class="dv">5</span> //<span class="co"> result is 10</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="higher-order-functions" class="level3">
<h3 class="anchored" data-anchor-id="higher-order-functions">Higher-Order Functions</h3>
<p>고차 함수는 다른 함수를 인수로 받거나 함수를 결과로 반환하는 함수입니다. 이 개념은 함수형 프로그래밍의 강력한 기능으로, 보다 선언적이고 모듈화된 스타일의 코딩을 가능하게 합니다. 일반적인 고차 함수 중 하나는 목록의 각 요소에 주어진 함수를 적용하는 맵입니다: 이 경우 List.map은 제곱을 인수로 받아 각 요소에 숫자로 적용하여 새로운 목록 [1; 4; 9; 16; 25]를 생성하는 고차 함수입니다.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode fsharp code-with-copy"><code class="sourceCode fsharp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> numbers = <span class="op">[</span><span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span><span class="op">]</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> square x = x * x</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> squaredNumbers = List<span class="kw">.</span>map square numbers</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>고차 함수의 또 다른 예로는 술어 함수를 기반으로 요소를 선택하는 필터가 있습니다: 여기서 List.filter는 isEven 함수를 술어로 사용하여 숫자에서 짝수 목록을 반환합니다.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode fsharp code-with-copy"><code class="sourceCode fsharp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> isEven x = x % <span class="dv">2</span> = <span class="dv">0</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> evenNumbers = List<span class="kw">.</span>filter isEven numbers</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="function-composition-and-partial-application" class="level3">
<h3 class="anchored" data-anchor-id="function-composition-and-partial-application">Function Composition and Partial Application</h3>
<p>F#은 고차 함수와 관련된 함수 합성과 부분 적용을 지원합니다. <code>&gt;&gt;</code>는 합성 연산자로, add1을 적용한 다음 multiply2를 적용하는 새 함수 add1ThenMultiply2를 만듭니다. 부분 적용은 함수에 여러 인수를 고정하여 다른 함수를 생성하는 것을 말합니다.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode fsharp code-with-copy"><code class="sourceCode fsharp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add1 x = x + <span class="dv">1</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> multiply2 x = x * <span class="dv">2</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add1ThenMultiply2 = add1 &gt;&gt; multiply2</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> result = add1ThenMultiply2 <span class="dv">3</span> //<span class="co"> result is 8</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>여기서 거듭제곱은 두 개의 인수를 받는 함수입니다. 파워에 2를 부분적으로 적용하여 인수의 거듭제곱으로 2를 계산하는 새로운 함수 제곱을 생성하여 효과적으로 제곱합니다.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode fsharp code-with-copy"><code class="sourceCode fsharp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> power <span class="kw">base</span> exponent = pown <span class="kw">base</span> exponent</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> square = power <span class="dv">2</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> result = square <span class="dv">3</span> //<span class="co"> result is 8</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="anonymous-functions" class="level3">
<h3 class="anchored" data-anchor-id="anonymous-functions">Anonymous Functions</h3>
<p>합성과 부분 적용을 위해서 익명 함수 또는 람다 식을 활용합니다.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode fsharp code-with-copy"><code class="sourceCode fsharp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> numbers = <span class="op">[</span><span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span><span class="op">]</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> squaredNumbers = List<span class="kw">.</span>map <span class="op">(</span><span class="kw">fun</span> x -&gt; x * x<span class="op">)</span> numbers</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="function-currying" class="level3">
<h3 class="anchored" data-anchor-id="function-currying">Function Currying</h3>
<p>F# 함수는 기본적으로 커링되어 있으므로 각각 단일 인수를 사용하는 일련의 함수로 자동 변환됩니다. 커링을 사용하면 함수를 보다 유연하게 적용할 수 있습니다. 여기서 add는 5를 부분적으로 적용하여 add5로 커링됩니다. 이제 add5는 입력에 5를 더하는 함수가 됩니다. 실용적인 예제 효과적인 함수형 코드를 작성하려면 일차 및 고차 함수를 이해하는 것이 중요합니다. 이러한 함수는 달성 방법보다는 달성하고자 하는 것을 설명하는 선언적 스타일을 촉진합니다. 이는 보다 간결하고 재사용 가능하며 읽기 쉬운 코드로 이어집니다.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode fsharp code-with-copy"><code class="sourceCode fsharp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add x y = x + y</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add5 = add <span class="dv">5</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> result = add5 <span class="dv">3</span> //<span class="co"> result is 8</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="recursive-functions-and-tail-recursion" class="level3">
<h3 class="anchored" data-anchor-id="recursive-functions-and-tail-recursion">Recursive Functions and Tail Recursion</h3>
<p>함수형 프로그래밍에서 재귀는 기존의 반복 구조 없이 반복적인 작업을 수행하는 데 사용되는 기본 개념입니다. F#은 재귀를 광범위하게 활용하여 반복적이거나 계층적인 데이터 구조와 관련된 문제에 대한 우아한 솔루션을 제공합니다. 이 섹션에서는 재귀 함수를 정의하고, 꼬리 재귀를 이해하고, F#의 성능에 미치는 영향을 살펴봅니다.</p>
</section>
<section id="defining-recursive-functions" class="level3">
<h3 class="anchored" data-anchor-id="defining-recursive-functions">Defining Recursive Functions</h3>
<p>재귀 함수는 정의 내에서 스스로를 호출하여 문제를 더 작은 하위 문제로 분해하여 해결하는 함수입니다. 재귀의 대표적인 예는 숫자의 계승을 계산하는 것으로, 함수를 호출할 때마다 숫자에 숫자의 계승에서 1을 뺀 값을 곱하는 것입니다:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode fsharp code-with-copy"><code class="sourceCode fsharp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> factorial n =</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> n &lt;= <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">else</span> n * factorial <span class="op">(</span>n - <span class="dv">1</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이 계승 함수에서 rec 키워드는 함수가 재귀적임을 나타내는 데 사용됩니다. 이 함수는 n이 1보다 작거나 같은지 확인하며, 이 경우 1을 반환합니다. 그렇지 않으면 n에 n - 1의 계승을 곱하여 문제 크기를 재귀적으로 줄입니다. 또 다른 예로는 피보나치 수열이 있는데, 각 숫자는 앞의 두 숫자의 합입니다:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode fsharp code-with-copy"><code class="sourceCode fsharp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fibonacci n =</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> n &lt;= <span class="dv">1</span> <span class="kw">then</span> n</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">else</span> fibonacci <span class="op">(</span>n - <span class="dv">1</span><span class="op">)</span> + fibonacci <span class="op">(</span>n - <span class="dv">2</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이 피보나치 함수는 또한 재귀를 사용하여 위치 n에서 피보나치 수를 계산합니다. 기본 사례(n &lt;= 1)에 도달할 때까지 문제를 계속 세분화한 다음 더 작은 하위 문제의 결과를 결합합니다.</p>
</section>
<section id="tail-recursion" class="level3">
<h3 class="anchored" data-anchor-id="tail-recursion">Tail Recursion</h3>
<p>재귀는 간단하고 우아할 수 있지만 호출 스택의 증가로 인해 성능 문제가 발생할 수 있습니다. 각 재귀 호출은 스택에 새 프레임을 추가하므로 재귀 깊이가 너무 크면 스택 오버플로 오류가 발생할 수 있습니다. 꼬리 재귀는 이 문제를 완화하는 데 도움이 되는 기술입니다. 꼬리 재귀 함수는 재귀 호출이 함수의 최종 연산이 되는 재귀 함수입니다. 이를 통해 F# 컴파일러는 재귀를 최적화하여 새 함수를 만드는 대신 현재 함수의 스택 프레임을 재사용할 수 있습니다.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode fsharp code-with-copy"><code class="sourceCode fsharp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> factorial n =</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> factorialTail acc n =</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> n &lt;= <span class="dv">1</span> <span class="kw">then</span> acc</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> factorialTail <span class="op">(</span>acc * n<span class="op">)</span> <span class="op">(</span>n - <span class="dv">1</span><span class="op">)</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    factorialTail <span class="dv">1</span> n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>factorialTail에 대한 재귀 호출은 함수의 마지막 연산이므로 꼬리 재귀가 됩니다. 이렇게 하면 재귀적으로 호출할 때마다 스택이 커지는 것을 방지할 수 있습니다. 마찬가지로 피보나치 함수를 꼬리 재귀적으로 리팩터링할 수 있습니다. 여기서 피보나치테일은 피보나치 수열에서 앞의 두 숫자를 나타내는 두 개의 a와 b를 유지합니다. 재귀 호출은 마지막 연산으로 꼬리 재귀 최적화를 보장합니다.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode fsharp code-with-copy"><code class="sourceCode fsharp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fibonacci n =</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> fibonacciTail a b n =</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> a</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> fibonacciTail b <span class="op">(</span>a + b<span class="op">)</span> <span class="op">(</span>n - <span class="dv">1</span><span class="op">)</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    fibonacciTail <span class="dv">0</span> <span class="dv">1</span> n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="benefits-of-tail-recursion" class="level3">
<h3 class="anchored" data-anchor-id="benefits-of-tail-recursion">Benefits of Tail Recursion</h3>
<ul>
<li>성능 향상
<ul>
<li>꼬리 재귀 함수는 컴파일러가 일정한 스택 공간에서 실행되도록 최적화할 수 있으므로 스택 오버플로의 위험을 줄이고 심층 재귀의 성능을 향상시킬 수 있음습니다.</li>
</ul></li>
<li>코드 정리
<ul>
<li>꼬리 재귀 함수는 특히 재귀에 자연스럽게 적합한 문제의 경우 반복 솔루션에 비해 더 깔끔하고 가독성 높은 코드를 생성하는 경우가 많음</li>
</ul></li>
<li>함수형 프로그래밍 패러다임
<ul>
<li>꼬리 재귀는 불변성과 선언적 문제 해결을 강조함으로써 함수형 프로그래밍 원칙에 부합</li>
</ul></li>
<li>실용적인 고려 사항
<ul>
<li>재귀 함수에 명확하고 정확한 베이스 케이스가 있는지 확인하여 무한 재귀와 잠재적인 스택 오버플로를 방지</li>
<li>재귀 깊이가 클 수 있는 경우 함수를 꼬리 재귀로 리팩터링하여 컴파일러 최적화를 활용</li>
<li>꼬리 재귀는 성능을 향상시키지만 코드 가독성과 유지보수성을 우선, 많은 문제에서 간단한 재귀 솔루션이 복잡한 꼬리 재귀 솔루션보다 더 이해하기 쉽고 유지 관리가 쉬움</li>
</ul></li>
<li>실제 사용 예
<ul>
<li>데이터 처리
<ul>
<li>재귀 함수는 트리나 그래프와 같은 계층적 데이터 구조를 처리하는 데 자주 사용되며, 각 노드나 에지는 재귀적인 방식으로 처리될 수 있음</li>
</ul></li>
<li>알고리즘 설계
<ul>
<li>정렬 및 검색과 같은 많은 알고리즘은 재귀를 사용해 문제를 더 작고 관리하기 쉬운 조각으로 분해</li>
</ul></li>
<li>수학적 계산
<ul>
<li>재귀 함수는 조합 문제나 수학적 방법과 같이 작은 하위 문제로 자연스럽게 표현할 수 있는 수학 문제를 푸는 데 유용</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="function-composition-and-partial-application-1" class="level3">
<h3 class="anchored" data-anchor-id="function-composition-and-partial-application-1">Function Composition and Partial Application</h3>
<p>함수형 프로그래밍에서 함수 합성과 부분 적용은 유연성과 표현력을 향상시키는 핵심 개념입니다. 이러한 기술을 통해 개발자는 더 간단한 함수로 복잡한 함수를 만들고, 사용을 간소화하며, 코드 재사용을 촉진할 수 있습니다. 함수 합성은 두 개 이상의 함수를 결합하여 새로운 함수를 만드는 것을 말합니다. F#에서 함수 합성은 합성(composition) 연산자(<code>&gt;&gt;</code>, <code>&lt;&lt;</code>)를 사용하여 쉽게 수행할 수 있습니다. 함수 합성을 사용하면 간단한 연산에서 복잡한 연산을 만들어 코드를 더 읽기 쉽고 재사용 가능하게 만들 수 있습니다.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode fsharp code-with-copy"><code class="sourceCode fsharp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">double</span> x = x <span class="dv">2</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> addTen x = x + <span class="dv">10</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> doubleAndAddTen = <span class="dt">double</span> &gt;&gt; addTen</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> result = doubleAndAddTen <span class="dv">5</span> //<span class="co"> Result is 20 (5_ 2 + 10)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="backward-composition" class="level3">
<h3 class="anchored" data-anchor-id="backward-composition">Backward Composition</h3>
<p>역방향 구성은 함수를 반대 순서로 합성하는 개념입니다. F#에서는 이를 위해 <code>&lt;&lt;</code> 연산자를 사용합니다. <code>addTen &lt;&lt; double</code>을 사용하면 addTen이 double 다음에 적용됩니다. double이 먼저 적용된 다음 addTen이 결과에 적용됩니다.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode fsharp code-with-copy"><code class="sourceCode fsharp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> addTenThenDouble = addTen <span class="st">&lt;&lt; double</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="st">let result = addTenThenDouble 5 // Result is 20 (5 \* 2 + 10)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="partial-application" class="level3">
<h3 class="anchored" data-anchor-id="partial-application">Partial Application</h3>
<p>부분 적용이란 일부 인수만 사용하고, 나머지 인수를 지연하여 바인딩하여 마치 새로운 함수를 정의하는 것 같은 효과를 제공하는 기법이다. 이 기술을 사용하면 함수를 재정의하지 않고도 특수한 버전의 함수를 만들 수 있습니다. 거듭제곱 함수를 부분적으로 적용하여 숫자의 제곱을 계산하는 새 함수를 만들 수 있습니다. 여기서 <code>power 2.0</code>은 기본 인수가 2.0으로 고정된 부분적으로 적용된 함수입니다. 새로운 함수 제곱은 지수 인수만 필요합니다. 부분 적용은 함수 호출을 간소화하고 코드 재사용을 촉진합니다. 일부 인수를 수정하여 필요에 맞는 보다 구체적인 함수를 만들 수 있습니다.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode fsharp code-with-copy"><code class="sourceCode fsharp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> power <span class="kw">base</span> exponent = <span class="kw">base</span> ** exponent</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> square = power <span class="fl">2.0</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> result = square <span class="fl">3.0</span> //<span class="co"> Result is 8.0 (2.0** 3.0)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="combining-composition-and-partial-application" class="level3">
<h3 class="anchored" data-anchor-id="combining-composition-and-partial-application">Combining Composition and Partial Application</h3>
<p>함수 합성과 부분 적용을 결합하여 강력하고 유연한 함수를 만들 수 있습니다. 부분적으로 적용된 함수를 구성하여 복잡한 연산을 재정의 할 수 있습니다. <code>multiplyBy2</code>와 <code>addFive</code>는 부분 적용된 함수입니다. 함수 합성으로 구성된 <code>multiplyAndAdd</code>는 먼저 2를 곱한 다음 5를 더합니다.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode fsharp code-with-copy"><code class="sourceCode fsharp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> multiplyBy factor = <span class="kw">fun</span> x -&gt; x * factor</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> multiplyBy2 = multiplyBy <span class="dv">2</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> addOffset offset x = x + offset</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> addFive = addOffset <span class="dv">5</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> multiplyAndAdd = multiplyBy2 &gt;&gt; addFive</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> result = multiplyAndAdd <span class="dv">10</span> //<span class="co"> Result is 25 (( 10 * 2) + 5)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>


</section>
</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../notes/fsharp04.html" class="pagination-link" aria-label="F# - 타입">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">F# - 타입</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright 2024, Sangkon Han</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/sigmadream/practice-fsharp/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>